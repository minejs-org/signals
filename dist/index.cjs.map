{"version":3,"sources":["../src/index.ts"],"names":["currentEffect","currentRoot","batchDepth","batchedEffects","flushedEffects","signal","initialValue","value","subscribers","read","write","newValue","fn","update","peek","subscribe","sig","effect","cleanup","isDisposed","execute","prevEffect","result","disposer","computed","batch","effects","untrack","on","prevValue","store","initialState","key","memo","cachedValue","hasCachedValue","root","disposers","prevRoot","d","dev","isSignal","isComputed","index_default"],"mappings":"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","file":"index.cjs","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\r\n// src/index.ts\r\n//\r\n// Made with ❤️ by Maysara.\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\r\n\r\n    import { Signal, EffectCleanup, Computed } from './types';\r\n    export type * from './types';\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\r\n\r\n    let currentEffect       : (() => void)   | null = null;\r\n    let currentRoot         : (() => void)[] | null = null;\r\n    let batchDepth          : number                = 0;\r\n    const batchedEffects    : Set<() => void>       = new Set<() => void>();\r\n    const flushedEffects    : Set<() => void>       = new Set<() => void>();\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\r\n\r\n    /**\r\n     * Creates a reactive signal that can be read, written, and subscribed to.\r\n     * @template T - The type of value stored in the signal\r\n     * @param {T} initialValue - The initial value of the signal\r\n     * @returns {Signal<T>} A signal object with read, set, update, peek, and subscribe methods\r\n     * @example\r\n     * const count = signal(0);\r\n     * console.log(count()); // 0\r\n     * count.set(5); // Update value\r\n     */\r\n    export function signal<T>(initialValue: T): Signal<T> {\r\n        let value           = initialValue;\r\n        const subscribers   = new Set<() => void>();\r\n\r\n        function read(): T {\r\n            // Track dependency if inside effect\r\n            if (currentEffect) {\r\n                subscribers.add(currentEffect);\r\n            }\r\n            return value;\r\n        }\r\n\r\n        function write(newValue: T): void {\r\n            // Only update if value actually changed\r\n            if (Object.is(value, newValue)) return;\r\n\r\n            value = newValue;\r\n\r\n            // Notify all subscribers\r\n            if (batchDepth > 0) {\r\n                // Batch mode: collect effects\r\n                subscribers.forEach(fn => batchedEffects.add(fn));\r\n            } else {\r\n                // Immediate mode: run effects now\r\n                subscribers.forEach(fn => fn());\r\n            }\r\n        }\r\n\r\n        function update(fn: (prev: T) => T): void {\r\n            write(fn(value));\r\n        }\r\n\r\n        function peek(): T {\r\n            // Read without tracking\r\n            return value;\r\n        }\r\n\r\n        function subscribe(fn: () => void): () => void {\r\n            subscribers.add(fn);\r\n            return () => subscribers.delete(fn);\r\n        }\r\n\r\n        // Create signal function with methods\r\n        const sig = read as Signal<T>;\r\n        sig.set = write;\r\n        sig.update = update;\r\n        sig.peek = peek;\r\n        sig.subscribe = subscribe;\r\n\r\n        return sig;\r\n    }\r\n\r\n    /**\r\n     * Automatically runs a function when its signal dependencies change.\r\n     * @param {() => EffectCleanup} fn - The effect function to run. Can optionally return a cleanup function.\r\n     * @returns {() => void} A dispose function to stop the effect and clean up\r\n     * @example\r\n     * const count = signal(0);\r\n     * effect(() => {\r\n     *   console.log('Count:', count());\r\n     *   return () => console.log('Cleaning up');\r\n     * });\r\n     */\r\n    export function effect(fn: () => EffectCleanup): () => void {\r\n        let cleanup: (() => void) | undefined;\r\n        let isDisposed = false;\r\n\r\n        const execute = () => {\r\n            if (isDisposed) return;\r\n\r\n            // Run cleanup from previous execution\r\n            if (cleanup) {\r\n                cleanup();\r\n                cleanup = undefined;\r\n            }\r\n\r\n            // Set as current effect for dependency tracking\r\n            const prevEffect = currentEffect;\r\n            currentEffect = execute;\r\n\r\n            try {\r\n                // Run the effect function\r\n                const result = fn();\r\n\r\n                // Store cleanup if returned\r\n                if (typeof result === 'function') {\r\n                    cleanup = result;\r\n                }\r\n            } finally {\r\n                // Restore previous effect\r\n                currentEffect = prevEffect;\r\n            }\r\n        };\r\n\r\n        // Run immediately\r\n        execute();\r\n\r\n        // Create dispose function\r\n        const disposer = () => {\r\n            if (isDisposed) return;\r\n            isDisposed = true;\r\n            if (cleanup) cleanup();\r\n        };\r\n\r\n        // Register with current root if one exists\r\n        if (currentRoot) {\r\n            currentRoot.push(disposer);\r\n        }\r\n\r\n        // Return dispose function\r\n        return disposer;\r\n    }\r\n\r\n    /**\r\n     * Creates a computed signal that automatically updates when its dependencies change.\r\n     * The computation result is cached and only recomputed when dependencies change.\r\n     * @template T - The type of value computed\r\n     * @param {() => T} fn - The computation function\r\n     * @returns {Computed<T>} A read-only computed signal\r\n     * @example\r\n     * const count = signal(5);\r\n     * const doubled = computed(() => count() * 2);\r\n     * console.log(doubled()); // 10\r\n     */\r\n    export function computed<T>(fn: () => T): Computed<T> {\r\n        const sig = signal<T>(undefined as T);\r\n\r\n        // Create effect that updates the signal\r\n        effect(() => {\r\n            sig.set(fn());\r\n        });\r\n\r\n        // Mark as computed\r\n        const computed = sig as Computed<T>;\r\n        Object.defineProperty(computed, 'isComputed', {\r\n            value: true,\r\n            writable: false\r\n        });\r\n\r\n        return computed;\r\n    }\r\n\r\n    /**\r\n     * Groups multiple signal updates together, deferring effect execution until all updates complete.\r\n     * This improves performance by preventing cascading effect runs.\r\n     * @template T - The return type of the function\r\n     * @param {() => T} fn - A function that performs multiple signal updates\r\n     * @returns {T} The return value of the function\r\n     * @example\r\n     * const a = signal(1);\r\n     * const b = signal(2);\r\n     * batch(() => {\r\n     *   a.set(10);\r\n     *   b.set(20);\r\n     * }); // Effects only run once\r\n     */\r\n    export function batch<T>(fn: () => T): T {\r\n        batchDepth++;\r\n\r\n        try {\r\n            return fn();\r\n        } finally {\r\n            batchDepth--;\r\n\r\n            // If we're back at depth 0, flush batched effects\r\n            if (batchDepth === 0) {\r\n                // Keep batch mode active while flushing to prevent cascading effects\r\n                batchDepth++;\r\n                flushedEffects.clear();\r\n                try {\r\n                    // Keep running effects until no more are queued\r\n                    while (batchedEffects.size > 0) {\r\n                        const effects = Array.from(batchedEffects);\r\n                        batchedEffects.clear();\r\n                        effects.forEach(fn => {\r\n                            // Only run if we haven't run it in this batch\r\n                            if (!flushedEffects.has(fn)) {\r\n                                flushedEffects.add(fn);\r\n                                fn();\r\n                            }\r\n                        });\r\n                    }\r\n                } finally {\r\n                    batchDepth--;\r\n                    flushedEffects.clear();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reads signals without creating dependencies on them.\r\n     * Useful for accessing signal values without triggering effect re-runs.\r\n     * @template T - The return type of the function\r\n     * @param {() => T} fn - A function that accesses signals\r\n     * @returns {T} The return value of the function\r\n     * @example\r\n     * const count = signal(0);\r\n     * effect(() => {\r\n     *   const value = untrack(() => count()); // Won't trigger re-run\r\n     *   console.log(value);\r\n     * });\r\n     */\r\n    export function untrack<T>(fn: () => T): T {\r\n        const prevEffect = currentEffect;\r\n        currentEffect = null;\r\n\r\n        try {\r\n            return fn();\r\n        } finally {\r\n            currentEffect = prevEffect;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Runs an effect only when a specific signal changes, providing both new and previous values.\r\n     * @template T - The type of the signal\r\n     * @param {Signal<T>} sig - The signal to watch\r\n     * @param {(value: T, prevValue: T) => EffectCleanup} fn - Effect function called with new and previous values\r\n     * @returns {() => void} A dispose function to stop watching\r\n     * @example\r\n     * const count = signal(0);\r\n     * on(count, (newVal, oldVal) => {\r\n     *   console.log(`Changed from ${oldVal} to ${newVal}`);\r\n     * });\r\n     */\r\n    export function on<T>(\r\n        sig: Signal<T>,\r\n        fn: (value: T, prevValue: T) => EffectCleanup\r\n    ): () => void {\r\n        let prevValue = sig.peek();\r\n\r\n        return effect(() => {\r\n            // Read the signal to create dependency\r\n            const value = sig();\r\n\r\n            // Run callback without tracking new dependencies\r\n            const cleanup = untrack(() => fn(value, prevValue));\r\n            prevValue = value;\r\n            return cleanup;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a store object where each property is a signal.\r\n     * Provides a convenient way to manage multiple related reactive values.\r\n     * @template T - The type of the initial state object\r\n     * @param {T} initialState - An object with initial values\r\n     * @returns {{ [K in keyof T]: Signal<T[K]> }} An object with signals for each property\r\n     * @example\r\n     * const state = store({ count: 0, name: 'John' });\r\n     * console.log(state.count()); // 0\r\n     * state.name.set('Jane');\r\n     */\r\n    export function store<T extends Record<string, any>>(\r\n        initialState: T\r\n    ): { [K in keyof T]: Signal<T[K]> } {\r\n        const store = {} as any;\r\n\r\n        for (const key in initialState) {\r\n            store[key] = signal(initialState[key]);\r\n        }\r\n\r\n        return store;\r\n    }\r\n\r\n    /**\r\n     * Memoizes the result of an expensive computation, caching it indefinitely.\r\n     * Unlike computed, this doesn't depend on reactive signals.\r\n     * @template T - The type of the memoized value\r\n     * @param {() => T} fn - A function that performs the computation\r\n     * @returns {() => T} A function that returns the cached result\r\n     * @example\r\n     * const expensiveCalc = memo(() => {\r\n     *   return Array.from({ length: 1000 }).map(expensiveOp);\r\n     * });\r\n     * const result = expensiveCalc(); // Computed only once\r\n     */\r\n    export function memo<T>(fn: () => T): () => T {\r\n        let cachedValue: T | undefined;\r\n        let hasCachedValue = false;\r\n\r\n        return () => {\r\n            if (hasCachedValue) {\r\n                return cachedValue as T;\r\n            }\r\n\r\n            // Compute the value\r\n            const value = fn();\r\n\r\n            // Cache it\r\n            cachedValue = value;\r\n            hasCachedValue = true;\r\n\r\n            return value;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Creates a root scope for managing effect and computed signal lifecycles.\r\n     * All effects and disposers created within the function are collected and can be cleaned up together.\r\n     * @template T - The return type of the function\r\n     * @param {(dispose: () => void) => T} fn - A function that receives a dispose function\r\n     * @returns {T} The return value of the function\r\n     * @example\r\n     * const dispose = root((dispose) => {\r\n     *   effect(() => console.log('Running'));\r\n     *   return 42;\r\n     * });\r\n     * dispose(); // Cleans up all effects created in the root\r\n     */\r\n    export function root<T>(fn: (dispose: () => void) => T): T {\r\n        const disposers: (() => void)[] = [];\r\n        const prevRoot = currentRoot;\r\n        currentRoot = disposers;\r\n\r\n        try {\r\n            const dispose = () => {\r\n                disposers.forEach(d => d());\r\n                disposers.length = 0;\r\n                currentRoot = prevRoot;\r\n            };\r\n\r\n            return fn(dispose);\r\n        } finally {\r\n            currentRoot = prevRoot;\r\n        }\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ HELP ════════════════════════════════════════╗\r\n\r\n    /**\r\n     * Development utilities for debugging signal reactivity\r\n     */\r\n    export const dev = {\r\n        /**\r\n         * Returns the currently executing effect, or null if no effect is running\r\n         * @returns {(() => void) | null} The current effect function or null\r\n         */\r\n        getCurrentEffect(): (() => void) | null {\r\n            return currentEffect;\r\n        },\r\n\r\n        /**\r\n         * Returns the current batch depth (for debugging nested batch calls)\r\n         * @returns {number} The current batch nesting level\r\n         */\r\n        getBatchDepth(): number {\r\n            return batchDepth;\r\n        },\r\n\r\n        /**\r\n         * Returns the count of effects currently pending in the batch queue\r\n         * @returns {number} The number of batched effects waiting to run\r\n         */\r\n        getBatchedEffectsCount(): number {\r\n            return batchedEffects.size;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Type guard to check if a value is a signal\r\n     * @template T - The type of value the signal contains\r\n     * @param {any} value - The value to check\r\n     * @returns {boolean} True if the value is a signal\r\n     * @example\r\n     * if (isSignal(myValue)) {\r\n     *   console.log(myValue());\r\n     * }\r\n     */\r\n    export function isSignal<T>(value: any): value is Signal<T> {\r\n        return (\r\n            typeof value === 'function' &&\r\n            'set' in value &&\r\n            'update' in value &&\r\n            'peek' in value\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Type guard to check if a value is a computed signal\r\n     * @template T - The type of value the computed signal contains\r\n     * @param {any} value - The value to check\r\n     * @returns {boolean} True if the value is a computed signal\r\n     * @example\r\n     * if (isComputed(myValue)) {\r\n     *   console.log('This is a computed signal');\r\n     * }\r\n     */\r\n    export function isComputed<T>(value: any): value is Computed<T> {\r\n        return isSignal(value) && 'isComputed' in value;\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ ════ ════════════════════════════════════════╗\r\n\r\n    export default {\r\n        signal,\r\n        effect,\r\n        computed,\r\n        batch,\r\n        untrack,\r\n        on,\r\n        store,\r\n        memo,\r\n        root,\r\n        isSignal,\r\n        isComputed,\r\n        dev\r\n    };\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n"]}